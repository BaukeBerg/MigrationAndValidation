module CodeSysGenerator

import FileLocations;
import IO;
import List;
import ParseTree;
import PC20Syntax;
import String;
import Environment;
import CodesysSyntax;
import CodesysTypes;

import utility::Debugging;
import utility::FileUtility;
import utility::ListUtility;
import utility::MathUtility;
import utility::StringUtility;

import vis::ParseTree;

// Those variables are not declared, but are provided by the Framework the code is entered into 
public map[str,str] systemVariables = ("0.1" : "AlwaysOne",
                                       "0.2" : "SUPPLY_ERROR", 
                                       "0.3" : "_CLOCK_10ms",
                                       "1.0" : "_CLOCK_100ms",
                                       "1.1" : "_CLOCK_1s",
                                       "1.2" : "_CLOCK_10s",
                                       "1.3" : "_CLOCK_60s");

void generateFile(str outputPath, Tree plcModel, SymbolTable symbols)
{
  PlcProgram program = extractInformation(plcModel, symbols);
  generateProgram(outputPath, program);
}

PlcProgram extractInformation(Tree plcModel, SymbolTable symbols)
{
  includedLines = 0;
  hasOpenCondition = false;
  programLines = [];
  Variables variableList = convertSymbols(symbols);
  //variableList = simplifyVariables(variableList); => Do this with rewrite of symbols
  variableList += "\r\n(* Local variables generated by Rascal *)";
  visit(plcModel)
  {
    case AssignValue A:
    {
      includedLines += extractSize(A);
      programLines += extractStatements(A, symbols);
    }
    case AssignConstant A:
    {
      includedLines += extractSize(A);
      programLines += extractStatements(A, symbols);
    }
    
    case BitTrigger B:
    {
      includedLines += extractSize(B);
      <declaration, statements> = evaluateTrigger(B, symbols);
      variableList += declaration;
      programLines += statements;
    }
    
    case NopBlock NB:
    {
      includedLines += extractSize(NB);
      programLines += ["(* <NB> *)", "; (* DoNothing *)", "  "];
    }
    
    case LogicCondition LC:
    {
      if(hasOpenCondition) 
      {
        progamLines = closeIf(programLines);
        hasOpenCondition = false;        
      }
      includedLines += extractSize(LC);      
      visit(LC)
      {
        case LogicExpression LE:
        {
          programLines += ["(* <LC> *)", "IF <evaluateExpression(LE, symbols)> THEN <formatComment(LE, symbols)>"];
          hasOpenCondition = true;
        }
      }
    }
    
  }
  if(hasOpenCondition) 
  {
    programLines = closeIf(programLines);
    hasOpenCondition = false;        
  }
  debugPrint("Total line amount included: <includedLines>");
  return <variableList,programLines>;
}

Statements closeIf(Statements programLines)
{
  if("  " == last(programLines))
  {
    programLines = delete(programLines, size(programLines)-1); 
  }        
  programSize = size(programLines);
  for(line <- [1..programSize])
  {
    if(startsWith(programLines[programSize-line], "IF "))
    {
      break;
    }
    else
    {
      programLines[programSize-line] = "  " + programLines[programSize-line];
    } 
  }
  if(startsWith(last(programLines), "IF "))
  {
    programLines += ["  ; (* EMPTY_IF_GUARD *)"];
  }
  programLines += ["END_IF;", "  "];
  return programLines;  
}





SymbolTable addUndeclaredVariables(SymbolTable symbols, Tree parsedData)
{
  debugPrint("starting visit");
  visit(parsedData)
  {
    case WordAddress WA:
    { 
      varName = clipAndStrip("<WA>");
      if(false == contains(varName, symbols))
      { 
        debugPrint("unable to find --|<varName>|--");
        symbols += composeUnnamedDeclaration(varName, "INT");
      }
      
    }
    case BitAddress BA:
    {   
      varName = clipAndStrip("<BA>");      
      if(false == contains(varName, symbols))
      { 
        debugPrint("unable to find --|<varName>|--");
        symbols += composeUnnamedDeclaration(varName, "BOOL");        
      }
      
    }
    default:
      ;
      
  }
  return symbols;
}

Symbol composeUnnamedDeclaration(str inputData, str dataType)
{
  debugPrint("Generating declaration for <dataType> <inputData>");
	addressName = replaceAll(trim("<clipAndStrip(inputData)>"), ".", "_");
  addressName = replaceAll(addressName, "=", "");    
  return <"unnamed_<trim(addressName)>", clipAndStrip("<inputData>"), "", dataType>;
}

int extractSize(&T codeBlock)
{
  visit(codeBlock)
  {
    case SourceLineRange range:
    {
      sources = split("-", "<range>");
      from = parseInt("<sources[0]>");
      to = parseInt("<sources[1]>");
      return to - from;
    }
  }
  return 0;       
}

tuple[str declaration, list[str] statements] evaluateTrigger(BitTrigger B, SymbolTable symbols)
{
  Symbol variableInfo = <"", "", "", "R_TRIG">;
  statements = ["(* <B>*)"];
  variableName = "";
  LogicExpression logicExpression;
  visit(B)
  {
    case TriggerExpression TE:
    {
      visit(TE)
      {
        case TriggerResult TR:
        { 
          variableInfo.name = "TRIGGER_<TR>";
        }  
        case LogicExpression LE:
        {
          logicExpression = LE;          
        }
      }
    }
    case TriggerTarget TT:
    {
      variableInfo.address = "<TT>";
      variableName = retrieveVariableName(variableInfo.address, symbols);
      variableInfo.comment = variableName ;
    }
  }
  
  clkExp = evaluateExpression(logicExpression, symbols);
  statements += formatName(variableInfo.name);
  statements += "(";
  statements += "  CLK := <clkExp>, <formatComment(logicExpression, symbols)>";
  statements += "  Q =\> <retrieveVariableName(variableInfo.address, symbols)>, (* <retrieveComment(variableInfo.address, symbols)> *)";
  statements += ");";
  statements += "  "; 
  return <extractVariable(variableInfo), statements>;
}

str evaluateExpression(LogicExpression logic, SymbolTable symbols)
{
  totalExpression = trim("<logic>");
  debugPrint("Evaluating logic: --|<totalExpression>|---");
  special = systemVariable(totalExpression);
  if(!isEmpty(special))  
  {
    return special;
  }
  if(contains(totalExpression, symbols))
  {
    return retrieveVariableName(totalExpression, symbols);
  }
  return totalExpression;
}

str systemVariable(str expToCheck)
{
  try
  {
    return systemVariables[clipAndStrip(expToCheck)];
  }
  catch:
  {  
    return "";
  }
}

Statements extractStatements(AssignValue A, SymbolTable symbols)
{
  statements = ["(* <A> *)"];
  sourceAddresses = [];
  targetAddresses = [];
  visit(A)
  {
    case SourceRange SR:
    {
      debugPrint("Range: <SR>");
      visit(SR)
      {
        case FiveDigits F:
        {
          sourceAddresses += "<stripLeading("<F>", "0")>";
        }
      }
    }
    case TargetRange TR:
    {
      visit(TR)
      {
        case FiveDigits F:
        {
          targetAddresses += "<stripLeading("<F>", "0")>";
        }
      }
    }
  }
  for(index <- [0..size(sourceAddresses)])
  {
    debugPrint("Evaluating <index>");
    statements += evaluateAssign(symbols, sourceAddresses[index], targetAddresses[index]);
  }
  statements += "  "; 
  return statements;
}

Statements extractStatements(AssignConstant A, SymbolTable symbols)
{
  constantValue = -1;
  statements = ["(* <A> *)"];
  addresses = [];
  debugPrint("Generating asssing <A>");
  visit(A)
  {
    case ConstantValue C:
    {
      constantValue = parseInt("<C>");     
    }
    case AddressRange A:
    {
      visit(A)
      {
        case FiveDigits F:
        {
          addresses += "<stripLeading("<F>", "0")>";
        }
      }
    }      
  }
  for(address <- addresses)
  {
    statements += evaluateAssign(symbols, address, constantValue);  
  }
  statements += "  "; 
  return statements;
}

str formatComment(LogicExpression logicExpression, SymbolTable symbols)
{
  addresses = [];
  visit(logicExpression)
  {
    case BitAddress BA:
    {
      addresses += ["<BA>"];
    }
  }
  commentString = "(* ";
  for(address <- addresses)
  {
    if("" == systemVariable(address))
    {
      commentString += debugPrint("finding data for <address>:","<trim(retrieveComment(address, symbols))> ");
    }
    else
    {
      commentString += "SystemVariable";
    }    
  }
  return commentString + "*)";  
}

Statements evaluateAssign(SymbolTable symbols, str sourceAddress, str targetAddress)
{
  sourceName = retrieveVariableName(sourceAddress, symbols);
  targetName = retrieveVariableName(targetAddress, symbols);
  return["<targetName> := <sourceName>; (* <retrieveComment(sourceAddress, symbols)> ==\>\> <retrieveComment(targetAddress, symbols)> *)"];   
}

Statements evaluateAssign(SymbolTable symbols, str address, int constantValue)
{
  if(true == isBoolean(address, symbols))
  {
    Statements statements = [];
    for(bitAddress <- retrieveAddressList(address, symbols))
    {
      variableName = retrieveVariableName(bitAddress, symbols);
      println(variableName);
      statements += "<variableName> := <toUpperCase("<getBit(constantValue, lastInteger(bitAddress))>")> ; (* <retrieveComment(variableName, symbols)> *)";
    }    
    return statements;
  }
  else
  {
    variableName = retrieveVariableName(address, symbols);
    println(variableName);
    return ["<variableName> := <constantValue> ; (* <retrieveComment(variableName, symbols)> *)"];
  }
}

void generateProgram(str outputPath, PlcProgram program) = writeToFile(generatedFile(outputPath), generateOutput(program));
list[str] generateOutput(PlcProgram program)
{
  totalFile = ["PROGRAM PC20_CYCLE", "VAR"];
  totalFile += program.declarations;
  totalFile += "END_VAR";
  totalFile += program.programLines;
  totalFile += "END_PROGRAM";
  return totalFile;
} 

Variables simplifyVariables(SymbolTable symbols) = simplifyVariables(convertSymbols(symbols));
Variables simplifyVariables(Variables variables)
{
  variableTree = innermost visit(parseVariables(variables))
  {
    case (PlcVariableList)`<PlcVariable* prev><
                            IntName intName><Numeric number>_0 : INT ; (*<CommentContent comment0>*)<NewLine nl><
                            IntName intName><Numeric number>_1 : INT ; (*<CommentContent comment1>*)<NewLine nl><
                            IntName intName><Numeric number>_2 : INT ; (*<CommentContent comment2>*)<NewLine nl><
                            IntName intName><Numeric number>_3 : INT ; (*<CommentContent comment3>*)<NewLine nl><
                            PlcVariable* rest>`:
    {
      debugPrint("Plc variable found: <intName>_<number>");
      debugPrint("Comment1: <comment0>");
      debugPrint("Comment2: <comment1>");
      debugPrint("Comment3: <comment2>");
      debugPrint("Comment4: <comment3>");
      textual = parse(#Name, "<trim("<intName>")>_<trim("<number>")>");      
      comment = parse(#DeclarationAndComment, " : INT ; (* <trim("<comment0>")> - <trim("<comment1>")> - <trim("<comment2>")> - <trim("<comment3>")> *)");
      insert((PlcVariableList)`<PlcVariable* prev><TextualName textual><DeclarationAndComment comment><PlcVariable* rest>`);
    }  
    
    // Array of Booleans
    case (PlcVariableList)`<PlcVariable *prev><
                           UpperCaseChars name>_<Numeric number><DeclarationAndComment details><
                           PlcVariable *next>`:
    {
      debugPrint("Array start: <name>");
      firstIndex = parseInt(number);   
      debugPrint("First index: <firstIndex>");   
      actualIndex = firstIndex+1;
      nextIndex = parse(#Numeric, "<actualIndex>");
      while( (PlcVariableList)`<UpperCaseChars name>_<Numeric number><DeclarationAndComment details><PlcVariable *newNext>` := (PlcVariableList)`<PlcVariable *next>`)
      {
        next = newNext;
        actualIndex += 1;
        nextIndex = parse(#Numeric, "<actualIndex>");       
      }
      arrayType = "NONE";
      visit(details)
      {
        case Type theType:
        {
          debugPrint("Type: <theType>");
          arrayType = trim("<theType>");
        }
        default:
        {
          ;
        }
      }      
      stringToParse = "<name>_<firstIndex>_<actualIndex> : ARRAY[<firstIndex>..<actualIndex>] OF <arrayType> ; (* Extracted aray *)";
      debugPrint("Array lay-out: <stringToParse>");
      array = parse(#PlcArray, stringToParse) ; 
      insert((PlcVariableList)`<PlcVariable *prev><PlcArray array><PlcVariable *next>`);      
    }    
  };
  renderParsetree(variableTree);
  variables = [];
  visit(variableTree)
  {
    case PlcVariable Var:
    {
      variables += trim("<Var>");
    }
  }
  return variables; 
}


Tree parseVariables(SymbolTable symbols) = parseVariables(convertSymbols(symbols));
Tree parseVariables(Variables variables)
{
  totalText = joinList(variables);
  writeFile(generatedFile("lastVarParser.symText"), totalText);
  return parse(#start[CodesysVariables], totalText);  
}

Variables convertSymbols(SymbolTable symbols) = [ extractVariable(plcSymbol) | plcSymbol <- symbols ];

str extractVariable(Symbol plcSymbol)
{
  dataType = plcSymbol.dataType;
  if("" == dataType)
  {
    dataType = typeString(plcSymbol.address);
  }  
  suffix = "; (* <plcSymbol.address> <plcSymbol.comment> *)";
  return "  <formatName(plcSymbol.name)> : <dataType> <suffix>";
}

str formatName(str variableName) = trim(replaceAll(replaceAll(variableName, ",", "_"), ".", "_"));
str typeString(str address) = contains(address, ".") ? "BOOL" : "INT" ;
